

// control flow

// if e {...} else {...}

// Classical control flow

def measureInBasis(b:!ğ”¹,x:ğ”¹):!ğ”¹{
    if b{
        x:= H(x);
        return measure(x);
    } else {
        return measure(x);
    }
}

// Quantum control flow

// esse exemplo muda y condicionado em x

def cnot(const x:ğ”¹, y:ğ”¹):ğ”¹{
    if x{
        y:= X(y);
    }
    return y;
}

// nos Quantum control flow, Silq impoes algumas restriÃ§Ãµes.

//def conditionalMensure[n:!â„•](const b:ğ”¹, x:uint[n]):ğŸ™{
//    if b{
//        x:=measure(x);
//    }
//}


// Loops

// while e {...}
// e tem que ser classico

def geometric():â„•{
    count := 0;
    ok := true;
    while ok {
        count += 1;
        ok = measure(H(false));
    }
    return count;
}

// Assignments

// for i in [e1..e2]{...}
// for i in (e1..e2){...}

def uniformSuperposition[n:!â„•]():ğ”¹^n{
    vec := vector(n,0:ğ”¹);
    for i in [0..n){
        vec[i] := H(vec[i]);
    }
    return vec
}


// Indexing

def main(){
    x:= [0,1,2,3];
    return x[3];
}