// Type annotation

// permite uma reinterpretaÃ§Ã£o do tipo de uma expressÃ£o se
// nÃ£o for necessÃ¡ria uma conversÃ£o no runtime

// cria uma representaÃ§Ã£o do 0 em diferentes tipos
def zeroes(){
    a:=0:!ğ”¹; // classico bit no estado zero
    b:=a:ğ”¹; // quantum bit no estado zero
    c:=0:uint[3]; // quantum 3-bit integer nÃ£o 'unsigned'
    d:=vector(4,false):ğ”¹[]; // quantum 4-bit vector
    return (a,b,c,d);
}

// Por definiÃ§Ã£o, valores constantes sÃ£o considerados clasicos
// Para criar um quantum constant. O Silq requer um tipo explicito de anotaÃ§Ã£o

def plusState():ğ”¹{
    x := false: ğ”¹;
    x := H(x);
    return x;
}

// escrevendo x:=false no lugar de x:=falseğ”¹ no plusState
// resulta num x sendo clasico, significando que nÃ£o ser pro H(x).

// Safe type conversion

// Safe type conversion (as) permite mudar o tipo de uma expressÃ£o convertendo 
// valores na excusÃ£o de um tipo pro outro. Eles sÃ£o permitido se as conversÃµes forem
// seguras

def safe_convertion(){
    //!int[32] para !â„¤
    a:=0:!int[32];
    b:=a as !â„¤;

    // !â„¤ para !int[32]
    c:=0:!â„¤;
    d:=c as !int[32];

    // ğ”¹^10 para int[10]
    e:=vector(10,0:ğ”¹);
    f:=e as int[10];

    //int[10] para ğ”¹^10
    g:=0:int[10];
    h:=g as ğ”¹^10;

    // convertendo element-wise
    i:=(0,1,2):!â„•^3;
    j:=i as !â„•Ã—!â„¤Ã—!int[3];
}

// Type coersion

// type coersion Ã© uma alternativa nÃ£o segura para type casts,
// que Ã© necessÃ¡rio sempre que a transformaÃ§Ã£o de tipo pode lanÃ§ar uma exceÃ§Ã£o de tempo de execuÃ§Ã£o.

def unsafe_conversions(){
    //coerce array to vector
    a:=array(4,true):ğ”¹[];
    b:=a coerce ğ”¹^4
}