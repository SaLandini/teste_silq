// silq suports annotations, !, qfree, mfree, const, and lifted


//Para indicar que o tipo de t deve ter valor classicos, e nÃ£o 'superpositions', a gente anota como !t.

// A funÃ§Ã£o pega dois argumentos x (boolean classico) e f

def classicalExample(x:!ğ”¹,f:!ğ”¹!â†’!ğ”¹){
  return f(x);             //  ^ f is classical
}

// NÃ£o classico
// Ela ilustra uma funÃ§Ã£o nÃ£o clasica. Ã© retorna a funÃ§Ã£o que 'which captures the quantum variable x'.
// Entretanto, o estado que Ã© pego estÃ¡ na 'superposition', significando que nÃ£o podemos pegar sendo classico

def captureQuantum(x:ğ”¹){
  captured := Î»(). { // function `captured` takes no arguments
    return H(x); // the body of function `captured` applies `H` to `x`
  };
  return captured:ğŸ™â†’ğ”¹;
                // ^ the returned function is not classical
}

//qfree

// Usamos o qfree pra indicar que as funÃ§Ãµes ou expressÃµes nÃ£o introduz ou destroi 'superpositions'.
// A anotaÃ§Ã£o qfree (i) garante que a avaliaÃ§Ã£o de funÃ§Ãµes qfree em argumentos clÃ¡ssicos produz resultados clÃ¡ssicos e 
// (ii) permite a descomputaÃ§Ã£o automÃ¡tica.

def myEvalqfree(f:ğ”¹â†’qfree ğ”¹)qfree{
  return f(true);
}

// mfree

// A anotaÃ§Ã£o de mfree indica que o funcionamento pode ser avaliada sem aplicar nenhuma medida

def myEvalmfree(f:ğ”¹â†’mfree ğ”¹)mfree{
  return f(false);
}


// const

// A anotaÃ§Ã£o const indica que tal variavel nÃ£o vai mudar no contexto dado.
// Assim, cada parametro de uma funÃ§Ã£o e cada variavÃ©l no contexto deve ser anotada sendo const
// Podemos usar parametros contanstes e variaveis mais 'liberally' deste que garantimos a percistencia do contexto

def myEvalconst(const x:ğ”¹, f: const ğ”¹!â†’ğ”¹) {
  return f(x)
}

//lifted 

// a lifted Ã© 'shorthand' para indicar funÃ§Ãµes qfree com apenas argumentos constante
// argumentos classicos sÃ£o implicitamente tratados como constantes

def myOr(x:ğ”¹, y:!ğ”¹)lifted{
  return x||y;
}